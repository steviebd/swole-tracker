import { describe, it, expect, vi, beforeEach } from "vitest";

// Import after mocking
import { whoopRouter } from "~/server/api/routers/whoop";
import { db } from "~/server/db";

describe("whoopRouter", () => {
  const mockUser = { id: "user-123" };
  const mockCtx = {
    db,
    user: mockUser,
    requestId: "test-request",
    headers: new Headers(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("getIntegrationStatus", () => {
    it("should return connected status when integration is active and not expired", async () => {
      const mockIntegration = {
        isActive: true,
        createdAt: new Date("2024-01-01"),
        expiresAt: new Date("2024-12-31"),
        scope:
          "read:profile read:recovery read:workout read:sleep read:cycle read:body_measurement",
      };

      (db as any).select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([mockIntegration]),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getIntegrationStatus();

      expect(result).toEqual({
        isConnected: true,
        connectedAt: mockIntegration.createdAt,
        expiresAt: mockIntegration.expiresAt,
        isExpired: false,
        scope: mockIntegration.scope,
      });
    });

    it("should return disconnected status when no integration exists", async () => {
      (db as any).select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([]),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getIntegrationStatus();

      expect(result).toEqual({
        isConnected: false,
        connectedAt: null,
        expiresAt: null,
        isExpired: false,
        scope: null,
      });
    });

    it("should return expired status when token is expired", async () => {
      const mockIntegration = {
        isActive: true,
        createdAt: new Date("2024-01-01"),
        expiresAt: new Date("2024-01-01"), // Already expired
        scope: "read:profile",
      };

      (db as any).select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([mockIntegration]),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getIntegrationStatus();

      expect(result).toEqual({
        isConnected: false,
        connectedAt: mockIntegration.createdAt,
        expiresAt: mockIntegration.expiresAt,
        isExpired: true,
        scope: mockIntegration.scope,
      });
    });

    it("should handle database errors gracefully", async () => {
      (db as any).select.mockImplementation(() => {
        throw new Error("Database connection failed");
      });

      const caller = whoopRouter.createCaller(mockCtx);

      await expect(caller.getIntegrationStatus()).rejects.toThrow(
        "Failed to check WHOOP integration status",
      );
    });
  });

  describe("getWorkouts", () => {
    it("should return WHOOP workouts for user", async () => {
      const mockWorkouts = [
        {
          id: 1,
          whoopWorkoutId: "workout-123",
          start: new Date("2024-01-01T10:00:00Z"),
          end: new Date("2024-01-01T11:00:00Z"),
          sport_name: "Running",
          score_state: "SCORED",
          score: 15.5,
          during: { heart_rate: 150 },
          zone_duration: { zone_one_duration: 1800 },
          createdAt: new Date(),
        },
      ];

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue(mockWorkouts),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getWorkouts();

      expect(result).toEqual(mockWorkouts);
    });

    it("should handle database errors gracefully", async () => {
      mockDb.select.mockImplementation(() => {
        throw new Error("Database connection failed");
      });

      const caller = whoopRouter.createCaller(mockCtx);

      await expect(caller.getWorkouts()).rejects.toThrow(
        "Failed to fetch WHOOP workouts",
      );
    });
  });

  describe("disconnectIntegration", () => {
    it("should deactivate WHOOP integration", async () => {
      mockDb.update.mockReturnValue({
        set: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue(undefined),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.disconnectIntegration();

      expect(result).toEqual({ success: true });
      expect(mockDb.update).toHaveBeenCalled();
    });
  });

  describe("getWebhookInfo", () => {
    it("should return webhook configuration info", async () => {
      // Mock environment variables
      const originalVercelUrl = process.env.VERCEL_URL;
      const originalNextAuthUrl = process.env.NEXTAUTH_URL;
      const originalWebhookSecret = process.env.WHOOP_WEBHOOK_SECRET;

      process.env.VERCEL_URL = "my-app.vercel.app";
      process.env.WHOOP_WEBHOOK_SECRET = "secret-key";

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getWebhookInfo();

      expect(result).toEqual({
        webhookUrl: "https://my-app.vercel.app/api/webhooks/whoop",
        isConfigured: true,
        supportedEvents: [
          "workout.updated",
          "recovery.updated",
          "sleep.updated",
          "cycle.updated",
          "body_measurement.updated",
          "user_profile.updated",
        ],
        instructions: expect.any(Array),
      });

      // Restore environment
      process.env.VERCEL_URL = originalVercelUrl;
      process.env.NEXTAUTH_URL = originalNextAuthUrl;
      process.env.WHOOP_WEBHOOK_SECRET = originalWebhookSecret;
    });

    it("should use NEXTAUTH_URL when VERCEL_URL is not available", async () => {
      const originalVercelUrl = process.env.VERCEL_URL;
      const originalNextAuthUrl = process.env.NEXTAUTH_URL;

      delete process.env.VERCEL_URL;
      process.env.NEXTAUTH_URL = "http://localhost:3000";

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getWebhookInfo();

      expect(result.webhookUrl).toBe(
        "http://localhost:3000/api/webhooks/whoop",
      );

      // Restore environment
      process.env.VERCEL_URL = originalVercelUrl;
      process.env.NEXTAUTH_URL = originalNextAuthUrl;
    });
  });

  describe("getLatestRecoveryData", () => {
    it("should return latest recovery data when integration is active", async () => {
      const mockIntegration = {
        isActive: true,
        expiresAt: new Date("2024-12-31"),
      };

      const mockRecovery = {
        recovery_score: 85,
        hrv_rmssd_milli: "45.2",
        hrv_rmssd_baseline: "42.1",
        resting_heart_rate: 60,
        resting_heart_rate_baseline: 65,
        raw_data: { some: "data" },
        date: new Date(),
      };

      const mockSleep = {
        sleep_performance_percentage: 92,
        raw_data: { sleep: "data" },
        start: new Date(),
      };

      mockDb.select = vi
        .fn()
        .mockReturnValueOnce({
          from: vi.fn().mockReturnValue({
            where: vi.fn().mockResolvedValue([mockIntegration]),
          }),
        })
        .mockReturnValueOnce({
          from: vi.fn().mockReturnValue({
            where: vi.fn().mockReturnValue({
              orderBy: vi.fn().mockReturnValue({
                limit: vi.fn().mockResolvedValue([mockRecovery]),
              }),
            }),
          }),
        })
        .mockReturnValueOnce({
          from: vi.fn().mockReturnValue({
            where: vi.fn().mockReturnValue({
              orderBy: vi.fn().mockReturnValue({
                limit: vi.fn().mockResolvedValue([mockSleep]),
              }),
            }),
          }),
        });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getLatestRecoveryData();

      expect(result).toEqual({
        recovery_score: 85,
        sleep_performance: 92,
        hrv_now_ms: 45.2,
        hrv_baseline_ms: 42.1,
        rhr_now_bpm: 60,
        rhr_baseline_bpm: 65,
        yesterday_strain: null,
        raw_data: {
          recovery: mockRecovery.raw_data,
          sleep: mockSleep.raw_data,
        },
      });
    });

    it("should throw error when integration is not active", async () => {
      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([]),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);

      await expect(caller.getLatestRecoveryData()).rejects.toThrow(
        "WHOOP integration not found or inactive",
      );
    });

    it("should throw error when token is expired", async () => {
      const mockIntegration = {
        isActive: true,
        expiresAt: new Date("2024-01-01"), // Expired
      };

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([mockIntegration]),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);

      await expect(caller.getLatestRecoveryData()).rejects.toThrow(
        "WHOOP access token has expired",
      );
    });

    it("should throw error when no recovery data exists", async () => {
      const mockIntegration = {
        isActive: true,
        expiresAt: new Date("2024-12-31"),
      };

      mockDb.select = vi
        .fn()
        .mockReturnValueOnce({
          from: vi.fn().mockReturnValue({
            where: vi.fn().mockResolvedValue([mockIntegration]),
          }),
        })
        .mockReturnValueOnce({
          from: vi.fn().mockReturnValue({
            where: vi.fn().mockReturnValue({
              orderBy: vi.fn().mockReturnValue({
                limit: vi.fn().mockResolvedValue([]), // No recovery data
              }),
            }),
          }),
        });

      const caller = whoopRouter.createCaller(mockCtx);

      await expect(caller.getLatestRecoveryData()).rejects.toThrow(
        "No recovery data found",
      );
    });
  });

  describe("getRecovery", () => {
    it("should return recovery data for user", async () => {
      const mockRecovery = [
        {
          id: 1,
          whoop_recovery_id: "recovery-123",
          cycle_id: "cycle-456",
          date: new Date(),
          recovery_score: 85,
          hrv_rmssd_milli: "45.2",
          hrv_rmssd_baseline: "42.1",
          resting_heart_rate: 60,
          resting_heart_rate_baseline: 65,
          raw_data: { some: "data" },
          createdAt: new Date(),
        },
      ];

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue(mockRecovery),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getRecovery();

      expect(result).toEqual(mockRecovery);
    });
  });

  describe("getCycles", () => {
    it("should return cycle data for user", async () => {
      const mockCycles = [
        {
          id: 1,
          whoop_cycle_id: "cycle-123",
          start: new Date("2024-01-01"),
          end: new Date("2024-01-02"),
          timezone_offset: "-05:00",
          day_strain: 15.5,
          average_heart_rate: 70,
          max_heart_rate: 180,
          kilojoule: 2500,
          raw_data: { cycle: "data" },
          createdAt: new Date(),
        },
      ];

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue(mockCycles),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getCycles();

      expect(result).toEqual(mockCycles);
    });
  });

  describe("getSleep", () => {
    it("should return sleep data for user", async () => {
      const mockSleep = [
        {
          id: 1,
          whoop_sleep_id: "sleep-123",
          start: new Date("2024-01-01T22:00:00Z"),
          end: new Date("2024-01-02T06:00:00Z"),
          timezone_offset: "-05:00",
          sleep_performance_percentage: 92,
          total_sleep_time_milli: "28800000",
          sleep_efficiency_percentage: 88,
          slow_wave_sleep_time_milli: "7200000",
          rem_sleep_time_milli: "5400000",
          light_sleep_time_milli: "14400000",
          wake_time_milli: "1800000",
          arousal_time_milli: "120000",
          disturbance_count: 3,
          sleep_latency_milli: "900000",
          raw_data: { sleep: "data" },
          createdAt: new Date(),
        },
      ];

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue(mockSleep),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getSleep();

      expect(result).toEqual(mockSleep);
    });
  });

  describe("getProfile", () => {
    it("should return WHOOP profile for user", async () => {
      const mockProfile = {
        id: 1,
        whoop_user_id: "whoop-user-123",
        email: "user@whoop.com",
        first_name: "John",
        last_name: "Doe",
        raw_data: { profile: "data" },
        last_updated: new Date(),
        createdAt: new Date(),
      };

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            limit: vi.fn().mockResolvedValue([mockProfile]),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getProfile();

      expect(result).toEqual(mockProfile);
    });

    it("should return null when no profile exists", async () => {
      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            limit: vi.fn().mockResolvedValue([]),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getProfile();

      expect(result).toBeNull();
    });
  });

  describe("getBodyMeasurements", () => {
    it("should return body measurements for user", async () => {
      const mockMeasurements = [
        {
          id: 1,
          whoop_measurement_id: "measurement-123",
          height_meter: 1.75,
          weight_kilogram: 75.5,
          max_heart_rate: 195,
          measurement_date: new Date("2024-01-01"),
          raw_data: { measurement: "data" },
          createdAt: new Date(),
        },
      ];

      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue(mockMeasurements),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getBodyMeasurements();

      expect(result).toEqual(mockMeasurements);
    });

    it("should return empty array when no measurements exist", async () => {
      mockDb.select.mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockReturnValue({
            orderBy: vi.fn().mockResolvedValue([]),
          }),
        }),
      });

      const caller = whoopRouter.createCaller(mockCtx);
      const result = await caller.getBodyMeasurements();

      expect(result).toEqual([]);
    });
  });
});
